.nolist
; The EZ80 plugin in VS Code keeps complaining "file not found" here
; Change the include line to "#include ".\ti83plus.inc" if you want to assemble using SPASM-ng"
; Or just execute in the ./src directory

#include ".\..\ti83plus.inc"
.list

; My plan is to create an AppVar on start-up
; then use it as a U8's registers and RAM savestate
; it's more general and works on 83+BE as well
; assume DE contains the address of the variable

; An AppVar has the following fields:
; Size - 2 bytes, little endian
; Data - size bytes

; so, this file need a HUGE refactorying

#include ".\..\u8mems.inc"
; ================

; Search for savestates, store their data pointers into a fixed-length table.
; $0000 = not found, empty; $0001 = archived
; In:		None
; Out:		None
; Destroys:	All
searchSaves:
	ld	hl,		saveTable
	push	hl				; push pointer into stack
	ld	hl,		ss_name
	rst	rMOV9TOOP1			; copy name into OP1
ss_loop:
	ld	hl,		OP1 + 8		; load the address of number
	inc	(hl)				; increment it
	ld	a,		'9'
	cp	(hl)				; compare number with '9'
	jr	z,		ss_done		; if equal, search is done
	rst	$38
	.dw	_ChkFindSym

	jr	c,		ss_notFound	; no such variable
	xor	a
	cp	b
	jr	nz,		ss_archived	; found but archived
	jr	ss_getAddr			; found and not archived
ss_notFound:
	ld	de,		0
	jr	ss_getAddr
ss_archived:
	ld	de,		1
ss_getAddr:
	pop	hl				; get pointer to table
	ld	(hl),		e
	inc	hl
	ld	(hl),		d		; save DE into it
	inc	hl
	push	hl				; push incremented pointer back
ss_done:
	pop	hl
	ret
ss_name:
	.db	AppVarObj
ci_header:
	.db	"Emu8"
	.db	"sav0"

; Creates a new instance whose name is pointed to by HL
; Memory should be checked before invoking this function.
; In:		HL - points to name
; Out:		HL - points to start of the savestate variable
; Destroys:	All
createInstance:
	rst	rMOV9TOOP1		; AppVar name
	ld	hl,		4395	; size
	rst	$38
	.dw	_CreateAppVar		; create the AppVar
	push	de			; preserve variable data pointer
	ld	hl,		ci_header
	ld	bc,		4
	ldir				; copy header into variable
	pop	hl			; restore variable data pointer
	ret

; Set up R/W memory for U8 emulation, also update pU8RAM
; In:		DE - points to start of a new savestate variable
;		HL - points to start of the savestate variable
; Out:		None
; Destroys:	All
loadstate:
	ld	bc,		4
	ldir					; copy header section
	ld	(pU8RAM),	de		; update pU8RAM
	ld	bc,		3584
	ldir					; copy RAM into new savestate
	ld	bc,		768
	ld	de,		U8SFR
	ldir					; copy SFR and VRAM section into saveSScreen
	ld	bc,		39
	ld	de,		U8regs
	ldir					; copy registers into tempSwapArea
	ret

; Save U8 memory into savestate file
; In:		DE - points to start of the savestate variable
; Out:		None
; Destroys:	All
savestate:
	ld	hl,		4
	add	hl,		de		; go past header
	ex	de,		hl
	ld	hl,		(pU8RAM)	; load U8 RAM pointer
	ld	bc,		3584
	ldir					; copy RAM into savestate
	ld	hl,		U8SFR
	ldir					; copy SFR and VRAM section
	ld	bc,		39
	ld	hl,		U8regs
	ldir					; copy registers
	ret

; Rename the temporary variable "Emu8sav0" to some other names
; No checks are made, only invoke this function AFTER createInstance
; In:		A - 

; following layout uses 4395 bytes

; Header "Emu8"		4	bytes
; RAM	$8000 - $8dff	3584	bytes
; SFR	$f000 - $f0ff	256	bytes
; VRAM	$f800 - $f9ff	512	bytes

; U8 registers		39	bytes
; R0		1
; R1		1
; R2		1
; R3		1
; R4		1
; R5		1
; R6		1
; R7		1
; R8		1
; R9		1
; R10		1
; R11		1
; R12		1
; R13		1
; R14		1
; R15		1

; PSW		1
; EPSW1		1
; EPSW2		1
; EPSW3		1

; SP		2

; CSR		1
; PC		2
; LCSR		1
; LR		2
; ECSR1		1
; ELR1		2
; ECSR2		1
; ELR2		2
; ECSR3		1
; ELR3		2

; EA		2
; AR is invisible to programmer. I will use HL instead.
